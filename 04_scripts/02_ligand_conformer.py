# -*- coding: utf-8 -*-
"""RDKit_conformer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PWbi_kHuqMoNkS1qzKCK27Mq3ipKIEpL
"""

import sys
print(sys.executable)

import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem, Lipinski
from rdkit.Chem.rdmolfiles import SDWriter
from pathlib import Path

TOPK = 3
SEED = 42

DEFAULT_N_CONFS = 30
DEFAULT_MIN_ITERS = 300
PRUNE_RMS = 0.5        # removes near-duplicate conformers

INPUT_CSV = "ligands_docking.csv"
out_dir = Path("conformers")
OUT_SUMMARY = "ligands_top3_summary.csv"

def choose_embed_and_min_settings(mol_noH):
    """check for large/flexible molecules."""
    heavy = Lipinski.HeavyAtomCount(mol_noH)
    rotb = Lipinski.NumRotatableBonds(mol_noH)

    # Adjust
    if heavy >= 80 or rotb >= 15:
        return 12, 180
    if heavy >= 60 or rotb >= 10:
        return 18, 200
    return DEFAULT_N_CONFS, DEFAULT_MIN_ITERS

def gen_topk_confs(smiles: str, name: str = "", topk: int = TOPK, seed: int = SEED):
    """
    Returns:
      - list of RDKit mols (each contains exactly 1 conformer)
      - ff_name ("MMFF94s" or "UFF")
      - list of dict meta per conformer (rank, cid, energy)
      - info dict (n_confs_requested, n_confs_generated, min_iters)
      - status string ("ok" or error)
    """
    mol0 = Chem.MolFromSmiles(smiles, sanitize=True)
    if mol0 is None:
        return [], None, [], {"n_confs_requested": None, "n_confs_generated": 0, "min_iters": None}, "invalid_smiles"

    n_confs, min_its = choose_embed_and_min_settings(mol0)

    mol = Chem.AddHs(mol0)

    # Embed multiple conformers
    params = AllChem.ETKDGv3()
    params.randomSeed = int(seed)
    params.numThreads = 0
    params.pruneRmsThresh = float(PRUNE_RMS)
    params.useRandomCoords = True  # macrocycles
    conf_ids = list(AllChem.EmbedMultipleConfs(mol, numConfs=int(n_confs), params=params))

    # Fallback
    if len(conf_ids) == 0:
        cid = AllChem.EmbedMolecule(mol, params=params)
        if cid < 0:
            return [], None, [], {"n_confs_requested": n_confs, "n_confs_generated": 0, "min_iters": min_its}, "embed_failed"
        conf_ids = [cid]

    # Pick force field (MMFF; else UFF)
    mmff_props = AllChem.MMFFGetMoleculeProperties(mol, mmffVariant="MMFF94s")
    use_mmff = mmff_props is not None
    ff_name = "MMFF94s" if use_mmff else "UFF"

    energies = []
    for cid in conf_ids:
        if use_mmff:
            ff = AllChem.MMFFGetMoleculeForceField(mol, mmff_props, confId=int(cid))
        else:
            ff = AllChem.UFFGetMoleculeForceField(mol, confId=int(cid))

        ff.Minimize(maxIts=int(min_its))
        e = float(ff.CalcEnergy())
        energies.append((int(cid), e))

    energies.sort(key=lambda x: x[1])
    top = energies[: min(int(topk), len(energies))]

    # One-mol-per-conformer for writing
    out_mols, meta = [], []
    for rank, (cid, e) in enumerate(top, start=1):
        m = Chem.Mol(mol)
        m.RemoveAllConformers()
        m.AddConformer(mol.GetConformer(cid), assignId=True)
        out_mols.append(m)
        meta.append({"conf_rank": rank, "conf_id": cid, "energy_kcalmol": e})

    info = {"n_confs_requested": n_confs, "n_confs_generated": len(conf_ids), "min_iters": min_its}
    return out_mols, ff_name, meta, info, "ok"

df = pd.read_csv(INPUT_CSV, encoding="ISO-8859-1")
df.columns = [c.strip() for c in df.columns]
df["Name"] = df["Name"].astype(str).str.strip()
df["SMILES"] = df["SMILES"].astype(str).str.strip()

writer = SDWriter(OUT_SDF)
summary_rows = []

for _, r in df.iterrows():
    name = r["Name"]
    smi = r["SMILES"]

    mols, ff_name, meta, info, status = gen_topk_confs(smi, name=name)

    if status != "ok":
        summary_rows.append({
            "Name": name,
            "SMILES": smi,
            "status": status,
            "forcefield": None,
            "conf_rank": None,
            "conf_id": None,
            "energy_kcalmol": None,
            **info,
        })
        continue

    for m, mmeta in zip(mols, meta):
        # Annotate SDF fields
        m.SetProp("_Name", f"{name}_conf{mmeta['conf_rank']}")
        m.SetProp("ParentName", name)
        m.SetProp("SMILES", smi)
        m.SetProp("ForceField", ff_name)
        m.SetProp("ConfRank", str(mmeta["conf_rank"]))
        m.SetProp("ConfId", str(mmeta["conf_id"]))
        m.SetProp("Energy_kcalmol", f"{mmeta['energy_kcalmol']:.6f}")
        m.SetProp("NConfsRequested", str(info["n_confs_requested"]))
        m.SetProp("NConfsGenerated", str(info["n_confs_generated"]))
        m.SetProp("MinIters", str(info["min_iters"]))

        writer.write(m)

        summary_rows.append({
            "Name": name,
            "SMILES": smi,
            "status": "ok",
            "forcefield": ff_name,
            "conf_rank": mmeta["conf_rank"],
            "conf_id": mmeta["conf_id"],
            "energy_kcalmol": mmeta["energy_kcalmol"],
            **info,
        })

writer.close()

summary = pd.DataFrame(summary_rows).sort_values(
    ["status", "Name", "conf_rank"],
    ascending=[True, True, True],
    na_position="last"
).reset_index(drop=True)

summary.to_csv(OUT_SUMMARY, index=False)

print(f"Wrote: {OUT_SDF}")
print(f"Wrote: {OUT_SUMMARY}")
display(summary.head(10))

