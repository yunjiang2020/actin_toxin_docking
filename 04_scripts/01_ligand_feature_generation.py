# -*- coding: utf-8 -*-
"""RDKit_ligand_feature.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XO2tdyCwuu0wm8upFZmKewd_l3TQnBmR
"""

import sys
print(sys.executable)

from rdkit import Chem
from rdkit.Chem import Descriptors, Lipinski

import pandas as pd
import numpy as np

df = pd.read_csv("ligands_docking.csv", encoding="ISO-8859-1")
df.columns = [c.strip() for c in df.columns]
df["SMILES"] = df["SMILES"].astype(str).str.strip()

def featurize(name, smi):
    mol = Chem.MolFromSmiles(smi, sanitize=True)
    if mol is None:
        return {
            "Name": name, "SMILES": smi, "valid": False,
            "Flag_any": True, "Flag_Category": "Invalid", "Flag_Reasons": "invalid_smiles"
        }

    # --- Core descriptors ---
    clogp = Descriptors.MolLogP(mol)              # Wildmanâ€“Crippen logP
    tpsa = Descriptors.TPSA(mol)                  # Topological polar surface area (Ertl)
    hbd  = Lipinski.NumHDonors(mol)               # H-bond donors
    hba  = Lipinski.NumHAcceptors(mol)            # H-bond acceptors
    mw   = Descriptors.MolWt(mol)                 # Molecular weight
    rotb = Lipinski.NumRotatableBonds(mol)        # Rotatable bonds
    rings= Lipinski.RingCount(mol)                # Ring count
    heavy= Lipinski.HeavyAtomCount(mol)           # Heavy atoms (non-H)
    fcsp3= Lipinski.FractionCSP3(mol)             # sp3 carbon fraction

    # --- Lipinski Ro5 violations ---
    # Classic Rule-of-Five thresholds: MW>500, cLogP>5, HBD>5, HBA>10
    lip_v = int(mw > 500) + int(clogp > 5) + int(hbd > 5) + int(hba > 10)

    # --- Flags ---
    flag_high_clogp = clogp > THRESH["cLogP_high"]
    flag_high_tpsa  = tpsa > THRESH["TPSA_high"]
    flag_high_rotb  = rotb > THRESH["RotB_high"]
    flag_high_mw    = mw   > THRESH["MW_high"]
    flag_low_mw     = mw   < THRESH["MW_low"]

    flag_any, flag_category, flag_reasons = categorize_flags(lip_v, mw, clogp, tpsa, rotb)

    return {
        "Name": name,
        "SMILES": smi,
        "valid": True,

        # Features
        "cLogP": round(clogp, 3),
        "TPSA": round(tpsa, 2),
        "HBD": int(hbd),
        "HBA": int(hba),
        "MW": round(mw, 2),
        "RotB": int(rotb),
        "Rings": int(rings),
        "HeavyAtoms": int(heavy),
        "FracCSP3": round(fcsp3, 3),

        # Lipinski summary
        "Lipinski_violations": int(lip_v),

        # Individual flags
        "Flag_high_cLogP": bool(flag_high_clogp),
        "Flag_high_TPSA": bool(flag_high_tpsa),
        "Flag_high_RotB": bool(flag_high_rotb),
        "Flag_high_MW": bool(flag_high_mw),
        "Flag_low_MW": bool(flag_low_mw),

        # Categorical flagging
        "Flag_any": bool(flag_any),
        "Flag_Category": flag_category,
        "Flag_Reasons": flag_reasons,
    }

def categorize_flags(lip_v, mw, clogp, tpsa, rotb):
    """
    Returns (flag_any: bool, flag_category: str, flag_reasons: str)
    Categories are prioritized: Invalid > VeryLarge > TooFlexible > TooPolar > TooHydrophobic > TooSmall > LipinskiOutlier > OK
    """
    reasons = []

    # Core threshold checks
    if mw > THRESH["MW_high"]:
        reasons.append("very_large_MW")
    if rotb > THRESH["RotB_high"]:
        reasons.append("too_flexible")
    if tpsa > THRESH["TPSA_high"]:
        reasons.append("too_polar_TPSA")
    if clogp > THRESH["cLogP_high"]:
        reasons.append("too_hydrophobic_cLogP")
    if mw < THRESH["MW_low"]:
        reasons.append("too_small_MW")
    if lip_v >= THRESH["Lipinski_bad"]:
        reasons.append(f"lipinski_violations>={THRESH['Lipinski_bad']}")

    # Category assignment (priority order)
    if "very_large_MW" in reasons:
        category = "VeryLarge"
    elif "too_flexible" in reasons:
        category = "TooFlexible"
    elif "too_polar_TPSA" in reasons:
        category = "TooPolar"
    elif "too_hydrophobic_cLogP" in reasons:
        category = "TooHydrophobic"
    elif "too_small_MW" in reasons:
        category = "TooSmall"
    elif any(r.startswith("lipinski_violations") for r in reasons):
        category = "LipinskiOutlier"
    else:
        category = "OK"

    flag_any = (category != "OK")
    return flag_any, category, ";".join(reasons) if reasons else ""

THRESH = {
    "cLogP_high": 5.0,
    "TPSA_high": 140.0,
    "RotB_high": 10,
    "MW_high": 600.0,
    "MW_low": 150.0,
    "Lipinski_bad": 2,   # highlight if >=2 Ro5 violations
}

feat = pd.DataFrame([featurize(n, s) for n, s in zip(df["Name"], df["SMILES"])])

# Surface potential issues first
feat = feat.sort_values(
    ["Flag_any", "Flag_Category", "Lipinski_violations", "MW"],
    ascending=[False, True, False, False]
).reset_index(drop=True)

feat.to_csv("ligand_features_with_flags.csv", index=False)

